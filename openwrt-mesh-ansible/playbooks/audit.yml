---
# Audit playbook for OpenWrt mesh nodes
# This playbook collects comprehensive system information for troubleshooting
#
# Usage:
#   # Run audit on single node
#   ansible-playbook -i inventory/hosts.yml playbooks/audit.yml --limit node1
#
#   # Run audit on all nodes
#   ansible-playbook -i inventory/hosts.yml playbooks/audit.yml
#
#   # Run with specific report directory
#   ansible-playbook -i inventory/hosts.yml playbooks/audit.yml \
#     -e "audit_report_dir=/path/to/reports"
#
# Output:
#   - JSON report: ./audit_reports/<hostname>_audit_YYYY-MM-DD_HH-MM-SS.json
#   - Preparation script: ./audit_reports/<hostname>_prepare.sh
#   - Console summary with key findings
#
###############################################################################

- name: Comprehensive Audit of OpenWrt Mesh Nodes
  hosts: mesh_nodes
  gather_facts: false
  vars:
    audit_report_dir: "{{ playbook_dir }}/../audit_reports"
    audit_timestamp: "{{ lookup('pipe', 'date +%Y-%m-%d_%H-%M-%S') }}"
    # Load package requirements from environment
    required_packages: >-
      {{ lookup('env', 'REQUIRED_PACKAGES') |
         default('python3,batctl-full,kmod-batman-adv,wpad-mesh-mbedtls,ip-full,tcpdump-mini,openssh-server,openssh-sftp-server,openssh-keygen', true) |
         split(',') | map('trim') | list }}
    remove_packages: >-
      {{ lookup('env', 'REMOVE_PACKAGES') |
         default('wpad-basic-mbedtls,wpad-basic-wolfssl,wpad-basic', true) |
         split(',') | map('trim') | list }}
    optional_packages: >-
      {{ lookup('env', 'OPTIONAL_PACKAGES') |
         default('iperf3,ethtool,nano,htop,rsync', true) |
         split(',') | map('trim') | list }}

  tasks:
    ###########################################################################
    # Phase 1: System Identification
    ###########################################################################

    - name: Wait for nodes to be reachable
      wait_for_connection:
        timeout: 30
      tags: [always]

    - name: Get system identification
      raw: |
        echo "=== Hardware Model ==="
        cat /tmp/sysinfo/model 2>/dev/null || echo "UNKNOWN"
        echo "=== Board Name ==="
        cat /tmp/sysinfo/board_name 2>/dev/null || echo "UNKNOWN"
        echo "=== OpenWrt Release ==="
        cat /etc/openwrt_release
        echo "=== Kernel Version ==="
        uname -a
      register: system_id
      changed_when: false
      tags: [system]

    - name: Get CPU and memory details
      raw: |
        echo "=== CPU Information ==="
        cat /proc/cpuinfo | grep -E "(model name|cpu model|Hardware|BogoMIPS|processor)" || echo "No CPU info"
        echo "CPU Count: $(grep -c ^processor /proc/cpuinfo 2>/dev/null || echo '1')"
        echo "=== Memory Information ==="
        free -m
        echo "=== Memory Details ==="
        cat /proc/meminfo | grep -E "^(MemTotal|MemFree|MemAvailable|Buffers|Cached|SwapTotal):" | head -10
      register: cpu_memory
      changed_when: false
      tags: [system]

    - name: Get storage information
      raw: |
        echo "=== Storage Usage ==="
        df -h
        echo "=== Mount Points ==="
        mount | grep -v "^overlay" | head -20
        echo "=== MTD Partitions ==="
        cat /proc/mtd 2>/dev/null || echo "No MTD partitions"
      register: storage_info
      changed_when: false
      tags: [system]

    - name: Get system time and NTP configuration
      raw: |
        echo "=== System Time ==="
        date
        echo "=== Timezone ==="
        uci -q get system.@system[0].timezone || echo "Not set"
        uci -q get system.@system[0].zonename || echo "Not set"
        echo "=== NTP Configuration ==="
        uci show system.ntp 2>/dev/null || echo "NTP not configured"
        echo "=== NTP Status ==="
        ntpq -p 2>/dev/null || echo "ntpq not available (run: opkg install ntpd)"
      register: time_ntp_config
      changed_when: false
      tags: [system, time]

    ###########################################################################
    # Phase 2: Network Infrastructure
    ###########################################################################

    - name: Get network interfaces and configuration
      raw: |
        echo "=== Network Interfaces ==="
        ip -br link show
        echo "=== IP Addresses ==="
        ip -br addr show
        echo "=== Routing Table ==="
        ip route show
        echo "=== Routing Rules ==="
        ip rule show
        echo "=== ARP Cache ==="
        ip neigh show | head -20
      register: network_interfaces
      changed_when: false
      tags: [network]

    - name: Get UCI network configuration
      raw: |
        echo "=== UCI Network Configuration ==="
        uci show network 2>/dev/null | grep -E "(interface|device|bridge)" | head -100
        echo "=== VLAN Configuration ==="
        ip link show | grep "@" || echo "No VLANs configured"
      register: uci_network
      changed_when: false
      tags: [network]

    ###########################################################################
    # Phase 3: Services and Processes
    ###########################################################################

    - name: Check system services
      raw: |
        echo "=== Enabled Services ==="
        for svc in network firewall dnsmasq dropbear sshd uhttpd odhcpd; do
          if [ -f /etc/init.d/$svc ]; then
            /etc/init.d/$svc enabled && echo "$svc: ENABLED" || echo "$svc: DISABLED"
          fi
        done
        echo "=== Running Services ==="
        for svc in dropbear sshd uhttpd dnsmasq odhcpd; do
          pidof $svc >/dev/null 2>&1 && echo "$svc: RUNNING (PID: $(pidof $svc))" || echo "$svc: STOPPED"
        done
      register: services_status
      changed_when: false
      tags: [services]

    - name: Get process information
      raw: |
        echo "=== System Uptime ==="
        uptime
        echo "=== Top Memory Consumers ==="
        ps | sort -r -k 3 | head -15
        echo "=== Network Services ==="
        netstat -tlpn 2>/dev/null | head -20 || ss -tlpn | head -20
      register: process_info
      changed_when: false
      tags: [services]

    ###########################################################################
    # Phase 4: Security Configuration
    ###########################################################################

    - name: Get SSH configuration
      raw: |
        echo "=== SSH Service Status ==="
        if [ -f /etc/config/dropbear ]; then
          echo "Dropbear Configuration:"
          uci show dropbear 2>/dev/null | head -20
        fi
        if [ -f /etc/ssh/sshd_config ]; then
          echo "OpenSSH Configuration:"
          grep -E "^(Port|PermitRootLogin|PasswordAuthentication|PubkeyAuthentication)" \
            /etc/ssh/sshd_config || echo "Default settings"
        fi
        echo "=== Authorized Keys ==="
        ls -la /root/.ssh/authorized_keys 2>/dev/null || echo "No authorized keys"
      register: ssh_config
      changed_when: false
      tags: [security]

    - name: Get firewall configuration
      raw: |
        echo "=== Firewall Zones ==="
        uci show firewall 2>/dev/null | grep -E "(zone|name|network|input|output|forward)" | head -40
        echo "=== Firewall Rules ==="
        iptables -L -n | head -50
        echo "=== NAT Rules ==="
        iptables -t nat -L -n | head -30
      register: firewall_config
      changed_when: false
      tags: [security]

    - name: Get DNS and DHCP configuration
      raw: |
        echo "=== DNS Configuration ==="
        cat /etc/resolv.conf
        echo "=== DHCP Server Configuration ==="
        uci show dhcp 2>/dev/null | grep -E "(dhcp|domain|server)" | head -30
        echo "=== Active DHCP Leases ==="
        cat /tmp/dhcp.leases 2>/dev/null | head -10 || echo "No active leases"
      register: dns_dhcp_config
      changed_when: false
      tags: [security]

    ###########################################################################
    # Phase 5: Mesh Network Status
    ###########################################################################

    - name: Check batman-adv status
      raw: |
        echo "=== Batman Module Status ==="
        lsmod | grep batman_adv || echo "Batman module NOT LOADED"
        echo "=== Batman Interfaces ==="
        batctl if 2>/dev/null || echo "No batman interfaces"
        echo "=== Mesh Neighbors ==="
        batctl n 2>/dev/null || echo "No mesh neighbors"
        echo "=== Mesh Routing Table ==="
        batctl o 2>/dev/null | head -20 || echo "No originators"
        echo "=== Gateway Configuration ==="
        batctl gw 2>/dev/null || echo "No gateway configured"
        batctl gwl 2>/dev/null || echo "No gateways available"
      register: batman_status
      changed_when: false
      tags: [mesh]

    ###########################################################################
    # Phase 6: Wireless Configuration
    ###########################################################################

    - name: Get wireless configuration and status
      raw: |
        echo "=== Wireless Devices ==="
        iw dev 2>/dev/null || echo "No wireless devices"
        echo "=== Wireless PHY Capabilities ==="
        for phy in /sys/class/ieee80211/phy*; do
          if [ -d "$phy" ]; then
            echo "PHY: $(basename $phy)"
            iw phy $(basename $phy) info 2>/dev/null | grep -E "(Band|MHz|HT|VHT)" | head -20
          fi
        done
        echo "=== UCI Wireless Configuration ==="
        uci show wireless 2>/dev/null | grep -E "(device|ssid|encryption|channel|htmode)" | head -50
        echo "=== Wireless Stations ==="
        for iface in $(iw dev 2>/dev/null | grep Interface | cut -d' ' -f2); do
          echo "Interface: $iface"
          iw $iface station dump 2>/dev/null | head -10
        done
      register: wireless_config
      changed_when: false
      tags: [wireless]

    ###########################################################################
    # Phase 7: Software Packages
    ###########################################################################

    - name: Get installed package names (simple list)
      raw: opkg list-installed | awk '{print $1}'
      register: installed_packages_simple
      changed_when: false
      tags: [packages]

    - name: Get installed packages with full versions
      raw: opkg list-installed
      register: installed_packages_full_raw
      changed_when: false
      tags: [packages]

    - name: Parse installed packages
      set_fact:
        # Use the simple list from awk, trim whitespace and filter out empty lines
        installed_packages: >-
          {{ installed_packages_simple.stdout_lines |
             map('trim') |
             select('match', '^[a-zA-Z0-9]') |
             list }}
        installed_packages_full: "{{ installed_packages_full_raw.stdout_lines }}"
      tags: [packages]

    - name: Debug raw package format
      debug:
        msg: |
          === SIMPLE PACKAGE NAMES (first 10 lines) ===
          {% for line in installed_packages_simple.stdout_lines[:10] | default([]) %}
          Line {{ loop.index }}: "{{ line }}"
          {% endfor %}
          === FULL PACKAGE INFO (first 5 lines) ===
          {% for line in installed_packages_full_raw.stdout_lines[:5] | default([]) %}
          Line {{ loop.index }}: "{{ line }}"
          {% endfor %}
          === TOTAL PACKAGES: {{ installed_packages_simple.stdout_lines | length }} ===
      tags: [packages, debug]

    - name: Debug parsed packages
      debug:
        msg: |
          === PARSED PACKAGES (first 20) ===
          {% for pkg in installed_packages[:20] | default([]) %}
          {{ loop.index }}: "{{ pkg }}"
          {% endfor %}
          === TOTAL PARSED: {{ installed_packages | length }} ===
      tags: [packages, debug]

    - name: Debug required packages
      debug:
        msg: |
          === REQUIRED PACKAGES ({{ required_packages | length }} total) ===
          {% for pkg in required_packages %}
          {{ loop.index }}: "{{ pkg }}"
          {% endfor %}
      tags: [packages, debug]

    - name: Check for specific packages
      debug:
        msg: |
          === CHECKING SPECIFIC PACKAGES ===
          python3 in installed: {{ 'python3' in installed_packages }}
          batctl-full in installed: {{ 'batctl-full' in installed_packages }}
          openssh-server in installed: {{ 'openssh-server' in installed_packages }}
          === SAMPLE CHECK (does any installed contain 'python') ===
          {% for pkg in installed_packages if 'python' in pkg %}
          Found: {{ pkg }}
          {% endfor %}
          === SAMPLE CHECK (does any installed contain 'ssh') ===
          {% for pkg in installed_packages if 'ssh' in pkg %}
          Found: {{ pkg }}
          {% endfor %}
      tags: [packages, debug]

    - name: Get package repository status
      raw: |
        echo "=== Repository Configuration ==="
        cat /etc/opkg/distfeeds.conf 2>/dev/null | head -20 || echo "No repository configuration"
        echo "=== Repository Update Status ==="
        opkg update --verbosity=0 2>&1 && echo "SUCCESS" || echo "FAILED"
        echo "=== Upgradable Packages ==="
        opkg list-upgradable 2>/dev/null | head -20 || echo "No upgradable packages"
      register: package_repos
      changed_when: false
      tags: [packages]

    ###########################################################################
    # Phase 8: System Health and Diagnostics
    ###########################################################################

    - name: Get system diagnostics
      raw: |
        echo "=== System Load ==="
        uptime
        cat /proc/loadavg
        echo "=== Kernel Messages (last 20) ==="
        dmesg | tail -20
        echo "=== System Log Errors/Warnings (last 20) ==="
        logread 2>/dev/null | grep -E "(err|warn|fail|crit)" | tail -20 || echo "No recent errors"
      register: system_diagnostics
      changed_when: false
      tags: [health]

    - name: Get hardware sensors
      raw: |
        echo "=== Temperature Sensors ==="
        for zone in /sys/class/thermal/thermal_zone*; do
          if [ -e "$zone/temp" ]; then
            temp=$(cat $zone/temp 2>/dev/null)
            type=$(cat $zone/type 2>/dev/null || echo "unknown")
            [ -n "$temp" ] && echo "$type: $(expr $temp / 1000)°C"
          fi
        done 2>/dev/null || echo "No thermal sensors"
        echo "=== USB Devices ==="
        ls /sys/bus/usb/devices/*/product 2>/dev/null | \
          while read f; do echo "USB: $(cat $f)"; done || echo "No USB devices"
      register: sensors_info
      changed_when: false
      tags: [health]

    ###########################################################################
    # Phase 9: USB Storage Audit
    ###########################################################################

    - name: Check USB storage devices
      raw: |
        echo "=== USB Storage Devices ==="
        if ls /dev/sd[a-z] 2>/dev/null | grep -q sd; then
          for dev in /dev/sd[a-z]; do
            if [ -b "$dev" ]; then
              SIZE=$(fdisk -l "$dev" 2>/dev/null | grep "^Disk /dev" | cut -d' ' -f3-4)
              echo "Device: $dev ($SIZE)"

              # Check partitions
              for part in ${dev}[0-9]; do
                if [ -b "$part" ]; then
                  FS_TYPE=$(blkid "$part" 2>/dev/null | sed 's/.*TYPE="\([^"]*\)".*/\1/')
                  FS_LABEL=$(blkid "$part" 2>/dev/null | sed 's/.*LABEL="\([^"]*\)".*/\1/')
                  echo "  Partition: $part - Type: ${FS_TYPE:-unknown} - Label: ${FS_LABEL:-none}"
                fi
              done
            fi
          done
        else
          echo "No USB storage devices detected"
        fi
      register: usb_devices
      changed_when: false
      tags: [storage, usb]

    - name: Check USB mount status
      raw: |
        echo "=== USB Mount Point /x00 ==="
        if [ -d /x00 ]; then
          if mount | grep -q "/x00"; then
            MOUNT_INFO=$(mount | grep "/x00")
            echo "Status: MOUNTED"
            echo "Mount: $MOUNT_INFO"
            echo ""
            echo "=== Storage Usage ==="
            df -h /x00
            echo ""
            echo "=== Contents Summary ==="
            if [ -r /x00 ]; then
              FILES=$(find /x00 -type f 2>/dev/null | wc -l)
              DIRS=$(find /x00 -type d 2>/dev/null | wc -l)
              TOTAL_SIZE=$(du -sh /x00 2>/dev/null | cut -f1)
              echo "Files: $FILES"
              echo "Directories: $DIRS"
              echo "Total Size: $TOTAL_SIZE"
              echo ""
              echo "=== Top Level Contents ==="
              ls -la /x00 2>/dev/null | head -10
            else
              echo "Mount point not readable"
            fi
          else
            echo "Status: NOT MOUNTED"
            echo "Mount point exists but no device mounted"
          fi
        else
          echo "Mount point /x00 does not exist"
        fi
      register: usb_mount_status
      changed_when: false
      tags: [storage, usb]

    - name: Check USB auto-mount configuration
      raw: |
        echo "=== USB Auto-mount Configuration ==="
        if [ -f /etc/config/fstab ]; then
          if uci show fstab 2>/dev/null | grep -q "target='/x00'"; then
            echo "UCI fstab configuration:"
            uci show fstab 2>/dev/null | grep -A5 "target='/x00'"
          else
            echo "No UCI configuration for /x00"
          fi
        fi
        echo ""
        echo "=== /etc/fstab entries ==="
        if grep -q "/x00" /etc/fstab 2>/dev/null; then
          grep "/x00" /etc/fstab
        else
          echo "No /etc/fstab entry for /x00"
        fi
      register: usb_automount_config
      changed_when: false
      tags: [storage, usb]

    - name: Check USB kernel modules
      raw: |
        echo "=== USB Storage Kernel Modules ==="
        # Check actual kernel module status (loaded or available as .ko)
        check_kmod() {
          local mod_name="$1"
          local kernel_name=$(echo "$mod_name" | sed 's/kmod-//' | tr '-' '_')
          # Check if loaded
          if lsmod | grep -q "^${kernel_name}"; then
            echo "$mod_name: LOADED"
            return 0
          fi
          # Check if .ko file exists (built into firmware but not loaded)
          if find /lib/modules/ -name "${kernel_name}.ko" 2>/dev/null | grep -q .; then
            echo "$mod_name: AVAILABLE (not loaded)"
            return 0
          fi
          echo "$mod_name: NOT AVAILABLE"
          return 1
        }

        for mod in kmod-usb-storage kmod-usb2 kmod-fs-f2fs kmod-fs-ext4; do
          check_kmod "$mod"
        done
        echo ""
        echo "=== USB Bus Information ==="
        lsusb 2>/dev/null | grep -v "root hub" || echo "lsusb not available"
      register: usb_modules
      changed_when: false
      tags: [storage, usb]

    ###########################################################################
    # Phase 10: Monitoring Audit
    # Checks for collectd, vnStat, health monitoring scripts
    ###########################################################################

    - name: Check if monitoring packages are installed
      raw: |
        echo "=== Monitoring Packages ==="
        for pkg in collectd vnstat luci-app-statistics luci-app-vnstat2 luci-app-commands; do
          if opkg list-installed | grep -q "^$pkg "; then
            echo "✓ $pkg - installed"
          else
            echo "✗ $pkg - not installed"
          fi
        done
      register: monitoring_packages
      changed_when: false
      tags: [monitoring, packages]

    - name: Check if monitoring services are running
      raw: |
        echo "=== Monitoring Services ==="
        for svc in collectd vnstat; do
          if /etc/init.d/$svc enabled 2>/dev/null; then
            STATUS=$(/etc/init.d/$svc status 2>&1)
            echo "$svc: enabled - $STATUS"
          else
            echo "$svc: not enabled"
          fi
        done
      register: monitoring_services
      changed_when: false
      tags: [monitoring, services]

    - name: Check monitoring data directories
      raw: |
        echo "=== Monitoring Data Directories ==="
        if [ -d "/x00/monitoring" ]; then
          echo "✓ /x00/monitoring exists"
          echo ""
          echo "--- Directory Structure ---"
          ls -lh /x00/monitoring/ 2>/dev/null || echo "Cannot list directory"
          echo ""
          echo "--- Disk Usage ---"
          du -sh /x00/monitoring/* 2>/dev/null || echo "No data yet"
          echo ""
          echo "--- Collectd RRD Files ---"
          if [ -d "/x00/monitoring/collectd/rrd" ]; then
            RRD_COUNT=$(find /x00/monitoring/collectd/rrd -name "*.rrd" 2>/dev/null | wc -l)
            echo "RRD files: $RRD_COUNT"
            find /x00/monitoring/collectd/rrd -name "*.rrd" 2>/dev/null | head -5 || true
          else
            echo "RRD directory not found"
          fi
          echo ""
          echo "--- vnStat Database ---"
          if [ -d "/x00/monitoring/vnstat" ]; then
            ls -lh /x00/monitoring/vnstat/ 2>/dev/null || echo "No vnStat data"
          else
            echo "vnStat directory not found"
          fi
          echo ""
          echo "--- Health Logs ---"
          if [ -f "/x00/monitoring/logs/mesh-health.log" ]; then
            echo "Latest health check entries:"
            tail -5 /x00/monitoring/logs/mesh-health.log 2>/dev/null || echo "Cannot read log"
          else
            echo "Health log not found"
          fi
        else
          echo "✗ /x00/monitoring does not exist (monitoring not deployed)"
        fi
      register: monitoring_data
      changed_when: false
      tags: [monitoring, data]

    - name: Check monitoring scripts
      raw: |
        echo "=== Monitoring Scripts ==="
        for script in /usr/bin/mesh-monitor.sh /usr/bin/monitoring-report.sh; do
          if [ -x "$script" ]; then
            echo "✓ $script - exists and executable"
          else
            echo "✗ $script - not found or not executable"
          fi
        done
      register: monitoring_scripts
      changed_when: false
      tags: [monitoring, scripts]

    - name: Check monitoring cron jobs
      raw: |
        echo "=== Monitoring Cron Jobs ==="
        if crontab -l 2>/dev/null | grep -q mesh-monitor; then
          echo "✓ Mesh health monitoring cron job exists:"
          crontab -l 2>/dev/null | grep mesh-monitor
        else
          echo "✗ Mesh health monitoring cron job not found"
        fi
        echo ""
        if crontab -l 2>/dev/null | grep -q "mesh-health.log"; then
          echo "✓ Log rotation cron job exists:"
          crontab -l 2>/dev/null | grep "mesh-health.log"
        else
          echo "✗ Log rotation cron job not found"
        fi
      register: monitoring_cron
      changed_when: false
      tags: [monitoring, cron]

    - name: Check collectd configuration
      raw: |
        echo "=== Collectd Configuration ==="
        if uci show luci_statistics 2>/dev/null | grep -q collectd; then
          echo "✓ Collectd UCI configuration exists"
          echo ""
          echo "--- Key Settings ---"
          echo "BaseDir: $(uci get luci_statistics.collectd.BaseDir 2>/dev/null || echo 'not set')"
          echo "Interval: $(uci get luci_statistics.collectd.Interval 2>/dev/null || echo 'not set')"
          echo "Hostname: $(uci get luci_statistics.collectd.Hostname 2>/dev/null || echo 'not set')"
          echo ""
          echo "--- Enabled Plugins ---"
          uci show luci_statistics | grep "\.enable='1'" | sed 's/luci_statistics\.collectd_//' | sed 's/\.enable=.*//' || echo "None"
          echo ""
          echo "--- RRDTool Settings ---"
          echo "DataDir: $(uci get luci_statistics.collectd_rrdtool.DataDir 2>/dev/null || echo 'not set')"
          echo "CacheFlush: $(uci get luci_statistics.collectd_rrdtool.CacheFlush 2>/dev/null || echo 'not set')"
        else
          echo "✗ Collectd UCI configuration not found"
        fi
      register: monitoring_config
      changed_when: false
      tags: [monitoring, config]

    - name: Check LuCI custom commands configuration
      raw: |
        echo "=== LuCI Custom Commands ==="
        if uci show luci | grep -q "command.*name='Mesh Neighbors'"; then
          COMMAND_COUNT=$(uci show luci | grep -c "\.command=command" || true)
          echo "✓ Custom commands configured ($COMMAND_COUNT commands)"
          echo ""
          echo "--- Configured Commands ---"
          uci show luci | grep "\.name=" | sed 's/.*\.name=/  - /' || true
        else
          echo "✗ Custom commands not configured"
        fi
      register: monitoring_luci_commands
      changed_when: false
      tags: [monitoring, luci]

    - name: Get monitoring web UI URL
      raw: |
        LANIP=$(ip -4 addr show br-lan 2>/dev/null | grep inet | awk '{print $2}' | cut -d/ -f1)
        if [ -n "$LANIP" ]; then
          echo "http://$LANIP/cgi-bin/luci/admin/statistics/graph"
        else
          echo "Unable to determine LAN IP"
        fi
      register: monitoring_web_ui
      changed_when: false
      tags: [monitoring]

    - name: Determine monitoring deployment status
      set_fact:
        monitoring_status:
          deployed: "{{ '/x00/monitoring' in monitoring_data.stdout }}"
          collectd_installed: "{{ 'collectd - installed' in monitoring_packages.stdout }}"
          vnstat_installed: "{{ 'vnstat - installed' in monitoring_packages.stdout }}"
          luci_vnstat_installed: "{{ 'luci-app-vnstat2 - installed' in monitoring_packages.stdout }}"
          luci_commands_installed: "{{ 'luci-app-commands - installed' in monitoring_packages.stdout }}"
          collectd_running: "{{ 'collectd: enabled - running' in monitoring_services.stdout }}"
          vnstat_running: "{{ 'vnstat: enabled - running' in monitoring_services.stdout }}"
          scripts_present: "{{ 'mesh-monitor.sh - exists' in monitoring_scripts.stdout and 'monitoring-report.sh - exists' in monitoring_scripts.stdout }}"
          cron_configured: "{{ 'Mesh health monitoring cron job exists' in monitoring_cron.stdout }}"
          custom_commands_configured: "{{ 'Custom commands configured' in monitoring_luci_commands.stdout }}"
          web_ui: "{{ monitoring_web_ui.stdout | trim }}"
      tags: [monitoring]

    ###########################################################################
    # Phase 10A: Distributed Syslog Audit
    ###########################################################################

    - name: Check syslog configuration and files
      raw: |
        echo "=== Syslog Configuration ==="
        LOG_FILE=$(uci -q get system.@system[0].log_file)
        LOG_SIZE=$(uci -q get system.@system[0].log_size)

        if [ -n "$LOG_FILE" ] && echo "$LOG_FILE" | grep -q "/x00"; then
          echo "✓ Syslog configured to USB: $LOG_FILE"
          echo "  Log size limit: ${LOG_SIZE:-128} KB"

          if [ -f "$LOG_FILE" ]; then
            SIZE=$(ls -lh "$LOG_FILE" 2>/dev/null | awk '{print $5}')
            LINES=$(wc -l < "$LOG_FILE" 2>/dev/null)
            echo "  Current log: $SIZE ($LINES lines)"
            echo ""
            echo "--- Last 5 entries ---"
            tail -5 "$LOG_FILE" 2>/dev/null
          else
            echo "  Log file not yet created (normal on fresh deploy)"
          fi
        else
          echo "✗ Syslog not configured for USB storage"
          echo "  Current log_file: ${LOG_FILE:-not set}"
        fi

        echo ""
        echo "=== Syslog Rotation ==="
        if crontab -l 2>/dev/null | grep -q "syslog"; then
          echo "✓ Rotation cron job configured"
          crontab -l 2>/dev/null | grep "syslog"
        else
          echo "✗ No rotation cron job found"
        fi
      register: syslog_data
      changed_when: false
      tags: [syslog]

    - name: Determine syslog status
      set_fact:
        syslog_status:
          configured: "{{ 'Syslog configured to USB' in syslog_data.stdout }}"
          has_logs: "{{ 'Current log:' in syslog_data.stdout }}"
          cron_configured: "{{ 'Rotation cron job configured' in syslog_data.stdout }}"
      tags: [syslog]

    ###########################################################################
    # Phase 11: Package Audit and Analysis
    ###########################################################################

    # Check kernel modules functionally (loaded or .ko file exists)
    # This handles modules baked into firmware via Image Builder
    # Uses simple checks to avoid Jinja2/shell escaping issues
    - name: Check kernel module availability
      raw: >-
        for pair in
        "kmod-batman-adv:batman_adv"
        "kmod-usb-storage:usb_storage"
        "kmod-usb2:ehci_hcd"
        "kmod-usb3:xhci_hcd"
        "kmod-fs-f2fs:f2fs"
        "kmod-fs-ext4:ext4"; do
        pkg=$(echo $pair | cut -d: -f1);
        mod=$(echo $pair | cut -d: -f2);
        if lsmod | grep -q "$mod" || find /lib/modules/ -name "$mod.ko" 2>/dev/null | grep -q .; then
        echo "$pkg:AVAILABLE";
        else
        echo "$pkg:MISSING";
        fi;
        done; exit 0
      register: kmod_check_raw
      changed_when: false
      tags: [audit, packages]

    - name: Parse kernel module availability
      set_fact:
        available_kmods: >-
          {{ kmod_check_raw.stdout_lines |
             select('match', '.*:AVAILABLE$') |
             map('regex_replace', ':AVAILABLE$', '') |
             list }}
      tags: [audit, packages]

    - name: Analyze package compliance
      set_fact:
        # Separate kernel modules from regular packages
        required_kmods: "{{ required_packages | select('match', '^kmod-') | list }}"
        required_regular: "{{ required_packages | reject('match', '^kmod-') | list }}"
      tags: [audit]

    - name: Calculate package audit results
      set_fact:
        package_audit:
          # Regular packages - check via opkg
          installed_required: "{{ installed_packages | intersect(required_regular) }}"
          missing_required_regular: "{{ required_regular | difference(installed_packages) }}"
          # Kernel modules - check via functional test (lsmod / .ko file)
          available_kmods: "{{ available_kmods | intersect(required_kmods) }}"
          missing_kmods: "{{ required_kmods | difference(available_kmods) }}"
          # Combined missing (only truly missing items)
          missing_required: "{{ (required_regular | difference(installed_packages)) | union(required_kmods | difference(available_kmods)) }}"
          conflicting: "{{ installed_packages | intersect(remove_packages) }}"
          installed_optional: "{{ installed_packages | intersect(optional_packages) }}"
          total_installed: "{{ installed_packages | length }}"
          audit_status: >-
            {{ 'ready' if (
                 (required_regular | difference(installed_packages) | length == 0) and
                 (required_kmods | difference(available_kmods) | length == 0) and
                 (installed_packages | intersect(remove_packages) | length == 0)
               ) else 'needs_preparation' }}
      tags: [audit]

    - name: Debug package audit results
      debug:
        msg: |
          === PACKAGE AUDIT DEBUG ===
          Required regular packages ({{ required_regular | length }}): {{ required_regular }}
          Required kernel modules ({{ required_kmods | length }}): {{ required_kmods }}

          Installed regular packages: {{ package_audit.installed_required | length }}/{{ required_regular | length }}
          Available kernel modules: {{ package_audit.available_kmods | length }}/{{ required_kmods | length }}

          Missing regular packages: {{ package_audit.missing_required_regular }}
          Missing kernel modules: {{ package_audit.missing_kmods }}
          Combined missing: {{ package_audit.missing_required }}
          Conflicts: {{ package_audit.conflicting }}

          Audit status: {{ package_audit.audit_status }}
      when: package_audit is defined
      tags: [audit, debug]

    ###########################################################################
    # Phase 12: Report Generation
    ###########################################################################

    - name: Create audit report directory
      file:
        path: "{{ audit_report_dir }}"
        state: directory
        mode: "0755"
      delegate_to: localhost
      run_once: true
      tags: [report]

    - name: Build comprehensive audit report
      set_fact:
        audit_report:
          metadata:
            hostname: "{{ inventory_hostname }}"
            timestamp: "{{ audit_timestamp }}"
            ansible_host: "{{ ansible_host }}"
          system:
            identification: "{{ system_id.stdout_lines }}"
            cpu_memory: "{{ cpu_memory.stdout_lines }}"
            storage: "{{ storage_info.stdout_lines }}"
          network:
            interfaces: "{{ network_interfaces.stdout_lines }}"
            configuration: "{{ uci_network.stdout_lines }}"
          services:
            status: "{{ services_status.stdout_lines }}"
            processes: "{{ process_info.stdout_lines }}"
          security:
            ssh: "{{ ssh_config.stdout_lines }}"
            firewall: "{{ firewall_config.stdout_lines }}"
            dns_dhcp: "{{ dns_dhcp_config.stdout_lines }}"
          mesh:
            batman_status: "{{ batman_status.stdout_lines }}"
          wireless:
            configuration: "{{ wireless_config.stdout_lines }}"
          usb_storage:
            devices: "{{ usb_devices.stdout_lines | default([]) }}"
            mount_status: "{{ usb_mount_status.stdout_lines | default([]) }}"
            automount_config: "{{ usb_automount_config.stdout_lines | default([]) }}"
            kernel_modules: "{{ usb_modules.stdout_lines | default([]) }}"
          monitoring:
            status: "{{ monitoring_status | default({}) }}"
            packages: "{{ monitoring_packages.stdout_lines | default([]) }}"
            services: "{{ monitoring_services.stdout_lines | default([]) }}"
            data_directories: "{{ monitoring_data.stdout_lines | default([]) }}"
            scripts: "{{ monitoring_scripts.stdout_lines | default([]) }}"
            cron_jobs: "{{ monitoring_cron.stdout_lines | default([]) }}"
            configuration: "{{ monitoring_config.stdout_lines | default([]) }}"
            luci_commands: "{{ monitoring_luci_commands.stdout_lines | default([]) }}"
            web_ui: "{{ monitoring_status.web_ui | default('Not deployed') }}"
          packages:
            installed_count: "{{ installed_packages | length }}"
            installed_list: "{{ installed_packages }}"
            full_list: "{{ installed_packages_full }}"
            repository_status: "{{ package_repos.stdout_lines }}"
          diagnostics:
            system_health: "{{ system_diagnostics.stdout_lines }}"
            sensors: "{{ sensors_info.stdout_lines }}"
          audit:
            package_compliance: "{{ package_audit }}"
            status: "{{ package_audit.audit_status }}"
      tags: [report]

    - name: Save audit report to JSON
      copy:
        content: "{{ audit_report | to_nice_json }}"
        dest: "{{ audit_report_dir }}/{{ inventory_hostname }}_audit_{{ audit_timestamp }}.json"
        mode: "0644"
      delegate_to: localhost
      tags: [report]

    - name: Generate preparation script
      template:
        src: ../templates/prepare_node.sh.j2
        dest: "{{ audit_report_dir }}/{{ inventory_hostname }}_prepare.sh"
        mode: "0755"
      delegate_to: localhost
      when: package_audit.audit_status != 'ready'
      tags: [report]

    ###########################################################################
    # Phase 13: Summary Display
    ###########################################################################

    - name: Display audit summary
      debug:
        msg: |
          ================================================================================
          AUDIT REPORT: {{ inventory_hostname }} ({{ ansible_host }})
          ================================================================================

          SYSTEM INFORMATION
          ------------------
          {{ system_id.stdout_lines[1] | default('Model: Unknown') }}
          {{ system_id.stdout_lines[5] | default('OpenWrt: Unknown') |
             regex_search('DISTRIB_DESCRIPTION=.*') |
             regex_replace('DISTRIB_DESCRIPTION=', 'Version: ') | regex_replace('"', '') }}
          {{ cpu_memory.stdout_lines[1] | default('CPU: Unknown') }}
          Memory: {{ cpu_memory.stdout_lines | select('match', '.*Mem:.*') |
                     first | default('Unknown') | regex_replace('^Mem:\\s+', '') }}
          Storage: {{ storage_info.stdout_lines | select('match', '^/dev/.*') | first | default('Unknown') }}

          NETWORK STATUS
          --------------
          Interfaces: {{ network_interfaces.stdout_lines | select('match', '^[0-9]+:.*') | list | length }}
          IP Addresses: {{ network_interfaces.stdout_lines | select('match', '.*inet .*') | list | length }}
          Batman Status: {{ 'ACTIVE' if 'batman_adv' in batman_status.stdout else 'NOT LOADED' }}
          Mesh Neighbors: {{ batman_status.stdout_lines |
                          select('match', '^[0-9a-f]{2}:[0-9a-f]{2}:.*') | list | length }}

          SERVICE STATUS
          --------------
          {% for line in services_status.stdout_lines %}
          {% if 'RUNNING' in line %}
          ✓ {{ line }}
          {% elif 'STOPPED' in line and 'dropbear' not in line %}
          ✗ {{ line }}
          {% endif %}
          {% endfor %}

          USB STORAGE
          -----------
          {% if 'Device: /dev/sd' in usb_devices.stdout %}
          {% for line in usb_devices.stdout_lines %}
          {% if 'Device:' in line %}
          {{ line }}
          {% elif 'Partition:' in line %}
            {{ line }}
          {% endif %}
          {% endfor %}
          {% else %}
          No USB storage devices detected
          {% endif %}
          Mount Point /x00: {{ 'MOUNTED' if 'Status: MOUNTED' in usb_mount_status.stdout else 'NOT MOUNTED' }}
          {% if 'df -h' in usb_mount_status.stdout and 'Status: MOUNTED' in usb_mount_status.stdout %}
          {% for line in usb_mount_status.stdout_lines %}
          {% if '/dev/sd' in line and '/x00' in line %}
          Storage Usage: {{ line.split()[2] }} used of {{ line.split()[1] }} ({{ line.split()[4] }})
          {% endif %}
          {% endfor %}
          {% endif %}
          Auto-mount: {{ 'CONFIGURED' if "target='/x00'" in usb_automount_config.stdout else 'NOT CONFIGURED' }}

          MONITORING
          ----------
          Status: {{ 'DEPLOYED' if monitoring_status.deployed else 'NOT DEPLOYED' }}
          {% if monitoring_status.deployed %}
          Collectd: {{ 'Installed & Running' if (monitoring_status.collectd_installed and monitoring_status.collectd_running) else 'Installed but not running' if monitoring_status.collectd_installed else 'Not installed' }}
          vnStat: {{ 'Installed & Running' if (monitoring_status.vnstat_installed and monitoring_status.vnstat_running) else 'Installed but not running' if monitoring_status.vnstat_installed else 'Not installed' }}
          LuCI Apps: {{ 'vnStat ✓' if monitoring_status.luci_vnstat_installed else 'vnStat ✗' }} | {{ 'Commands ✓' if monitoring_status.luci_commands_installed else 'Commands ✗' }}
          Custom Commands: {{ 'Configured' if monitoring_status.custom_commands_configured else 'Not configured' }}
          Health Scripts: {{ 'Present' if monitoring_status.scripts_present else 'Missing' }}
          Cron Jobs: {{ 'Configured' if monitoring_status.cron_configured else 'Not configured' }}
          Web UI: {{ monitoring_status.web_ui }}
          Data Directory: /x00/monitoring
          {% else %}
          To enable: Set ENABLE_MONITORING=true in .env and deploy node, or run: make deploy-monitoring NODE={{ node_number | default('N') }}
          {% endif %}

          DISTRIBUTED SYSLOG
          ------------------
          Status: {{ 'CONFIGURED' if syslog_status.configured else 'NOT CONFIGURED' }}
          {% if syslog_status.configured %}
          Log File: /x00/logs/syslog
          Log Data: {{ 'Available' if syslog_status.has_logs else 'Empty (normal on fresh deploy)' }}
          Rotation: {{ 'Configured (30 day retention)' if syslog_status.cron_configured else 'Not configured' }}
          {% else %}
          Requires USB storage at /x00 and monitoring deployment
          {% endif %}

          PACKAGE AUDIT
          -------------
          Total Installed: {{ package_audit.total_installed }} packages
          Regular Packages: {{ package_audit.installed_required | length }}/{{ required_regular | length }} installed
          Kernel Modules: {{ package_audit.available_kmods | length }}/{{ required_kmods | length }} available
          Missing: {{ package_audit.missing_required | length }}
          Conflicting: {{ package_audit.conflicting | length }}
          Status: {{ 'READY FOR DEPLOYMENT' if package_audit.audit_status == 'ready' else 'PREPARATION NEEDED' }}

          {% if package_audit.missing_required_regular | length > 0 %}
          MISSING REGULAR PACKAGES:
          {% for pkg in package_audit.missing_required_regular %}
            - {{ pkg }}
          {% endfor %}
          {% endif %}

          {% if package_audit.missing_kmods | length > 0 %}
          MISSING KERNEL MODULES:
          {% for pkg in package_audit.missing_kmods %}
            - {{ pkg }} (not loaded and .ko file not found)
          {% endfor %}
          {% endif %}

          {% if package_audit.conflicting | length > 0 %}
          CONFLICTING PACKAGES (must remove):
          {% for pkg in package_audit.conflicting %}
            - {{ pkg }}
          {% endfor %}
          {% endif %}

          FILES GENERATED
          ---------------
          Report: {{ audit_report_dir }}/{{ inventory_hostname }}_audit_{{ audit_timestamp }}.json
          {% if package_audit.audit_status != 'ready' %}
          Script: {{ audit_report_dir }}/{{ inventory_hostname }}_prepare.sh

          NEXT STEPS
          ----------
          1. Review the preparation script
          2. Copy to node: scp {{ audit_report_dir }}/{{ inventory_hostname }}_prepare.sh root@{{ ansible_host }}:/tmp/
          3. Execute: ssh root@{{ ansible_host }} 'sh /tmp/prepare.sh'
          4. Re-run audit to verify
          {% else %}

          ✅ Node is ready for deployment!
          {% endif %}

          ================================================================================
      tags: [summary]
