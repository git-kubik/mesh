---
# Package management role for OpenWrt mesh nodes
# Handles repository configuration, package updates, and installation
#
# Note: Variables are loaded from environment by the deploy.yml playbook
# via roles/common/tasks/load_env_vars.yml before this role runs.

- name: Configure local package repository (if enabled)
  ansible.builtin.raw: |
    # Backup original distfeeds.conf
    cp /etc/opkg/distfeeds.conf /etc/opkg/distfeeds.conf.orig

    # Get kernel module directory from repository
    KMOD_DIR=$(wget -qO- "{{ opkg_repo_url }}/targets/{{ openwrt_target }}/kmods/" | grep -oE 'href="[^"]+/"' | head -1 | sed 's/href="//;s/\/"//')

    # Configure local repository
    cat > /etc/opkg/distfeeds.conf << EOF
    # Local OpenWrt Package Repository
    src/gz openwrt_core {{ opkg_repo_url }}/packages/{{ openwrt_version }}/{{ openwrt_arch }}/base
    src/gz openwrt_base {{ opkg_repo_url }}/packages/{{ openwrt_version }}/{{ openwrt_arch }}/base
    src/gz openwrt_luci {{ opkg_repo_url }}/packages/{{ openwrt_version }}/{{ openwrt_arch }}/luci
    src/gz openwrt_packages {{ opkg_repo_url }}/packages/{{ openwrt_version }}/{{ openwrt_arch }}/packages
    src/gz openwrt_routing {{ opkg_repo_url }}/packages/{{ openwrt_version }}/{{ openwrt_arch }}/routing
    src/gz openwrt_telephony {{ opkg_repo_url }}/packages/{{ openwrt_version }}/{{ openwrt_arch }}/telephony
    src/gz openwrt_kmods {{ opkg_repo_url }}/targets/{{ openwrt_target }}/kmods/$KMOD_DIR
    src/gz openwrt_target {{ opkg_repo_url }}/targets/{{ openwrt_target }}/packages
    EOF

    echo "Local repository configured at {{ opkg_repo_url }}"
  when: opkg_repo_url != ''
  changed_when: true

- name: Update package lists
  ansible.builtin.raw: opkg update
  register: opkg_update
  changed_when: "'Updated list of available packages' in opkg_update.stdout"

- name: Upgrade pre-installed packages
  ansible.builtin.raw: |
    UPGRADABLE=$(opkg list-upgradable 2>/dev/null)
    if [ -n "$UPGRADABLE" ]; then
      echo "=== Packages to upgrade ==="
      echo "$UPGRADABLE"
      echo "=== Upgrading packages ==="
      opkg list-upgradable | cut -f 1 -d ' ' | xargs -r opkg upgrade
      echo "=== Upgrade complete ==="
    else
      echo "All pre-installed packages are up to date"
    fi
  register: upgrade_result
  changed_when: "'Upgrading' in upgrade_result.stdout"

- name: Display upgrade results
  ansible.builtin.debug:
    msg: "{{ upgrade_result.stdout_lines }}"
  when: upgrade_result.stdout_lines | length > 1

- name: Remove conflicting packages
  ansible.builtin.raw: "opkg remove {{ item }} --force-removal-of-dependent-packages"
  loop: "{{ remove_packages }}"
  register: remove_result
  changed_when: "'Removing package' in remove_result.stdout"
  failed_when: false

- name: Install required packages
  ansible.builtin.raw: |
    echo "=== Installing {{ item }} ==="
    # Attempt installation
    OUTPUT=$(opkg install {{ item }} 2>&1)
    RC=$?
    echo "$OUTPUT"

    # Check for opkg errors
    if [ $RC -ne 0 ]; then
      echo "ERROR: opkg install {{ item }} failed with exit code $RC"
      exit 1
    fi

    # Check for specific error messages that opkg returns with exit 0
    if echo "$OUTPUT" | grep -q "Cannot install package"; then
      echo "ERROR: Cannot install package {{ item }}"
      exit 1
    fi

    # Verify package is actually installed (handle package name variations)
    # Some packages like python3 install as python3-light, batctl-full installs as batctl-full
    PKG_BASE=$(echo "{{ item }}" | sed 's/-full$//')
    if ! opkg list-installed | grep -qE "^({{ item }}|${PKG_BASE}) "; then
      echo "ERROR: {{ item }} not found in installed packages after installation"
      exit 1
    fi

    echo "SUCCESS: {{ item }} installed"
  loop: "{{ required_packages }}"
  register: install_result
  changed_when: "'Configuring' in install_result.stdout or 'Installing' in install_result.stdout"
  failed_when: install_result.rc != 0

- name: Display package installation results
  ansible.builtin.debug:
    msg: "{{ install_result.results | map(attribute='stdout_lines') | list }}"

- name: Verify critical packages installation
  ansible.builtin.raw: |
    echo "=== Verifying critical packages ==="
    FAILED=""
    for pkg in batctl-full kmod-batman-adv openssh-server curl; do
      PKG_BASE=$(echo "$pkg" | sed 's/-full$//')
      if opkg list-installed | grep -qE "^(${pkg}|${PKG_BASE}) "; then
        echo "OK: $pkg"
      else
        echo "MISSING: $pkg"
        FAILED="$FAILED $pkg"
      fi
    done
    if [ -n "$FAILED" ]; then
      echo "ERROR: Critical packages missing:$FAILED"
      exit 1
    fi
    echo "=== All critical packages verified ==="
  register: verify_critical
  changed_when: false
  failed_when: verify_critical.rc != 0

- name: Show critical package verification
  ansible.builtin.debug:
    msg: "{{ verify_critical.stdout_lines }}"

- name: Install optional packages
  ansible.builtin.raw: "opkg install {{ item }}"
  loop: "{{ optional_packages }}"
  register: optional_install_result
  changed_when: "'Installing' in optional_install_result.stdout"
  failed_when: false

# NOTE: Local repo config is kept for the entire deployment
# This allows monitoring and other roles to use the cached packages
# The distfeeds.conf.orig backup is preserved if manual restore is needed
